<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Psyche Project: psy::C::Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Psyche Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>psy</b></li><li class="navelem"><b>C</b></li><li class="navelem"><a class="el" href="classpsy_1_1_c_1_1_parser.html">Parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classpsy_1_1_c_1_1_parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">psy::C::Parser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The C <a class="el" href="classpsy_1_1_c_1_1_parser.html" title="The C Parser class.">Parser</a> class.  
 <a href="classpsy_1_1_c_1_1_parser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_parser_8h_source.html">Parser.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsy_1_1_c_1_1_parser_1_1_backtracker.html">Backtracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsy_1_1_c_1_1_parser_1_1_depth_control.html">DepthControl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsy_1_1_c_1_1_parser_1_1_diagnostics_reporter.html">DiagnosticsReporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsy_1_1_c_1_1_parser_1_1_diagnostics_reporter_delayer.html">DiagnosticsReporterDelayer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b4b6aa5e49fc3bc7ae6939981663b73"><td class="memItemLeft" align="right" valign="top"><a id="a0b4b6aa5e49fc3bc7ae6939981663b73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PSY_GRANT_ACCESS</b> (DebugRule)</td></tr>
<tr class="separator:a0b4b6aa5e49fc3bc7ae6939981663b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848124798c869bea8dcd91c07d86bddd"><td class="memItemLeft" align="right" valign="top"><a id="a848124798c869bea8dcd91c07d86bddd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Parser</b> (<a class="el" href="classpsy_1_1_c_1_1_syntax_tree.html">SyntaxTree</a> *tree)</td></tr>
<tr class="separator:a848124798c869bea8dcd91c07d86bddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690edbb665fe0c75d0ae79faabf688b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpsy_1_1_c_1_1_translation_unit_syntax.html">TranslationUnitSyntax</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a690edbb665fe0c75d0ae79faabf688b5">parse</a> ()</td></tr>
<tr class="separator:a690edbb665fe0c75d0ae79faabf688b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae525826d41ddefc2569277e9c5cbcaa8"><td class="memItemLeft" align="right" valign="top"><a id="ae525826d41ddefc2569277e9c5cbcaa8"></a>
PSY_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>__pad0__</b>: PSY_GRANT_ACCESS(<a class="el" href="classpsy_1_1_c_1_1_syntax_tree.html">SyntaxTree</a>)</td></tr>
<tr class="separator:ae525826d41ddefc2569277e9c5cbcaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a846861f4315842abc4c85dd23f57b3dd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a846861f4315842abc4c85dd23f57b3dd">DeclarationScope</a> : uint8_t { <b>File</b>, 
<b>Block</b>, 
<b>FunctionPrototype</b>
 }</td></tr>
<tr class="memdesc:a846861f4315842abc4c85dd23f57b3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scope of a declaration.  <a href="classpsy_1_1_c_1_1_parser.html#a846861f4315842abc4c85dd23f57b3dd">More...</a><br /></td></tr>
<tr class="separator:a846861f4315842abc4c85dd23f57b3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d26c370e34dcb351131e9b97c8b9d0e"><td class="memItemLeft" align="right" valign="top"><a id="a3d26c370e34dcb351131e9b97c8b9d0e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>DeclaratorVariety</b> : uint8_t { <b>Named</b>, 
<b>Abstract</b>
 }</td></tr>
<tr class="separator:a3d26c370e34dcb351131e9b97c8b9d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7c97d6a0889e82feb0e2cdc066eb35"><td class="memItemLeft" align="right" valign="top"><a id="acb7c97d6a0889e82feb0e2cdc066eb35"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>IdentifierRole</b> : uint8_t { <b>AsDeclarator</b>, 
<b>AsTypedefName</b>
 }</td></tr>
<tr class="separator:acb7c97d6a0889e82feb0e2cdc066eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f50464cb0306deacebba1eb9f6e21b"><td class="memItemLeft" align="right" valign="top"><a id="a19f50464cb0306deacebba1eb9f6e21b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>StatementContext</b> : uint8_t { <b>None</b>, 
<b>Switch</b>, 
<b>Loop</b>, 
<b>SwitchAndLoop</b>
 }</td></tr>
<tr class="separator:a19f50464cb0306deacebba1eb9f6e21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa3cbcfbc11bae056c7cfa0cef3a6c7c3"><td class="memItemLeft" align="right" valign="top"><a id="aa3cbcfbc11bae056c7cfa0cef3a6c7c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Parser</b> (const <a class="el" href="classpsy_1_1_c_1_1_parser.html">Parser</a> &amp;)=delete</td></tr>
<tr class="separator:aa3cbcfbc11bae056c7cfa0cef3a6c7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53521b55ec9a56ea1a115c97d57851f5"><td class="memItemLeft" align="right" valign="top"><a id="a53521b55ec9a56ea1a115c97d57851f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classpsy_1_1_c_1_1_parser.html">Parser</a> &amp;)=delete</td></tr>
<tr class="separator:a53521b55ec9a56ea1a115c97d57851f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f262cc92b22513be77df6427fac9a11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a8f262cc92b22513be77df6427fac9a11">mightBacktrack</a> () const</td></tr>
<tr class="separator:a8f262cc92b22513be77df6427fac9a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c48250ce91642a030b8037a2146c34"><td class="memItemLeft" align="right" valign="top"><a id="a88c48250ce91642a030b8037a2146c34"></a>
const <a class="el" href="classpsy_1_1_c_1_1_syntax_token.html">SyntaxToken</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>peek</b> (unsigned int LA=1) const</td></tr>
<tr class="separator:a88c48250ce91642a030b8037a2146c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89ea793a833a604de6670e57e950c04"><td class="memItemLeft" align="right" valign="top"><a id="ab89ea793a833a604de6670e57e950c04"></a>
LexedTokens::IndexType&#160;</td><td class="memItemRight" valign="bottom"><b>consume</b> ()</td></tr>
<tr class="separator:ab89ea793a833a604de6670e57e950c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4fbbe8241093a4db61be3ea92db204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#abd4fbbe8241093a4db61be3ea92db204">match</a> (SyntaxKind expectedTkK, LexedTokens::IndexType *tkIdx)</td></tr>
<tr class="separator:abd4fbbe8241093a4db61be3ea92db204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50355ed345e8f786649ad3dd70a86df9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a50355ed345e8f786649ad3dd70a86df9">matchOrSkipTo</a> (SyntaxKind expectedTkK, LexedTokens::IndexType *tkIdx)</td></tr>
<tr class="separator:a50355ed345e8f786649ad3dd70a86df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b9e29d4bf8a03a73c87238fe1df74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a31b9e29d4bf8a03a73c87238fe1df74a">skipTo</a> (SyntaxKind tkK)</td></tr>
<tr class="separator:a31b9e29d4bf8a03a73c87238fe1df74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae457c5fe9f3a180473397bcc5278c1d2"><td class="memTemplParams" colspan="2"><a id="ae457c5fe9f3a180473397bcc5278c1d2"></a>
template&lt;class NodeT , class... Args&gt; </td></tr>
<tr class="memitem:ae457c5fe9f3a180473397bcc5278c1d2"><td class="memTemplItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeNode</b> (Args &amp;&amp;... args) const</td></tr>
<tr class="separator:ae457c5fe9f3a180473397bcc5278c1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99667beb8a441fa17ce48730575f21fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a99667beb8a441fa17ce48730575f21fb">parseTranslationUnit</a> (<a class="el" href="classpsy_1_1_c_1_1_translation_unit_syntax.html">TranslationUnitSyntax</a> *&amp;unit)</td></tr>
<tr class="separator:a99667beb8a441fa17ce48730575f21fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af6f1747c824e8989f37b557f4ac3e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a9af6f1747c824e8989f37b557f4ac3e1">parseExternalDeclaration</a> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl)</td></tr>
<tr class="separator:a9af6f1747c824e8989f37b557f4ac3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b69a07659cc31ecda49e5606eb33a"><td class="memItemLeft" align="right" valign="top"><a id="a559b69a07659cc31ecda49e5606eb33a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseIncompleteDeclaration_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl, const <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *specList=nullptr)</td></tr>
<tr class="separator:a559b69a07659cc31ecda49e5606eb33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f82802e6eb142b61961b60faab4efc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a85f82802e6eb142b61961b60faab4efc">parseStaticAssertDeclaration_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl)</td></tr>
<tr class="separator:a85f82802e6eb142b61961b60faab4efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f27ff930220f92c7985f6a5d5c78eee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a2f27ff930220f92c7985f6a5d5c78eee">parseExtGNU_AsmStatementDeclaration_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl)</td></tr>
<tr class="separator:a2f27ff930220f92c7985f6a5d5c78eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b400613ed80c65725b250deaa9e5677"><td class="memItemLeft" align="right" valign="top"><a id="a3b400613ed80c65725b250deaa9e5677"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseDeclaration</b> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl, bool(Parser::*parseSpecifiers)(<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;), bool(Parser::*parse_AtFollowOfSpecifiers)(<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;, const <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *), <a class="el" href="classpsy_1_1_c_1_1_parser.html#a846861f4315842abc4c85dd23f57b3dd">DeclarationScope</a> declScope)</td></tr>
<tr class="separator:a3b400613ed80c65725b250deaa9e5677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728bbac45f245744d356e4001581f2bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a728bbac45f245744d356e4001581f2bb">parseDeclarationOrFunctionDefinition</a> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl)</td></tr>
<tr class="separator:a728bbac45f245744d356e4001581f2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7feeacbe39577d47371629cdf019b4"><td class="memItemLeft" align="right" valign="top"><a id="acd7feeacbe39577d47371629cdf019b4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseDeclarationOrFunctionDefinition_AtFollowOfSpecifiers</b> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl, const <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *specList)</td></tr>
<tr class="separator:acd7feeacbe39577d47371629cdf019b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8f9079c58e9e12f643aee5d90b6809"><td class="memItemLeft" align="right" valign="top"><a id="adf8f9079c58e9e12f643aee5d90b6809"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseFunctionDefinition_AtOpenBrace</b> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl, const <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *specList, <a class="el" href="classpsy_1_1_c_1_1_declarator_syntax.html">DeclaratorSyntax</a> *&amp;decltor, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">ExtKR_ParameterDeclarationListSyntax</a> *paramKRList)</td></tr>
<tr class="separator:adf8f9079c58e9e12f643aee5d90b6809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad842c96a58dff6e9d9a6e4f2101210a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ad842c96a58dff6e9d9a6e4f2101210a8">parseStructDeclaration</a> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl)</td></tr>
<tr class="separator:ad842c96a58dff6e9d9a6e4f2101210a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe29357832c8a17be6c8869345cad085"><td class="memItemLeft" align="right" valign="top"><a id="abe29357832c8a17be6c8869345cad085"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseStructDeclaration_AtFollowOfSpecifierQualifierList</b> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl, const <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *specList)</td></tr>
<tr class="separator:abe29357832c8a17be6c8869345cad085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ae7ee94ec11955694e327f32f3956a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a28ae7ee94ec11955694e327f32f3956a">parseEnumerator</a> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl)</td></tr>
<tr class="separator:a28ae7ee94ec11955694e327f32f3956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20695ee6cc25c03caa3f24951b6a3c93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a20695ee6cc25c03caa3f24951b6a3c93">parseParameterDeclarationListAndOrEllipsis</a> (<a class="el" href="classpsy_1_1_c_1_1_parameter_suffix_syntax.html">ParameterSuffixSyntax</a> *&amp;paramDecltorSfx)</td></tr>
<tr class="separator:a20695ee6cc25c03caa3f24951b6a3c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff9e41f2093e2373d355f68fab2926a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a1ff9e41f2093e2373d355f68fab2926a">parseParameterDeclarationList</a> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ParameterDeclarationListSyntax</a> *&amp;paramList)</td></tr>
<tr class="separator:a1ff9e41f2093e2373d355f68fab2926a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac379beaf1852b6356da4482869a09b9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ac379beaf1852b6356da4482869a09b9b">parseParameterDeclaration</a> (<a class="el" href="classpsy_1_1_c_1_1_parameter_declaration_syntax.html">ParameterDeclarationSyntax</a> *&amp;paramDecl)</td></tr>
<tr class="separator:ac379beaf1852b6356da4482869a09b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303bfd74f9c12186b7a53ddec7144dae"><td class="memItemLeft" align="right" valign="top"><a id="a303bfd74f9c12186b7a53ddec7144dae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtPSY_TemplateDeclaration_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl)</td></tr>
<tr class="separator:a303bfd74f9c12186b7a53ddec7144dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfebd7cb549b9f18013a867a116fe5eb"><td class="memItemLeft" align="right" valign="top"><a id="abfebd7cb549b9f18013a867a116fe5eb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtKR_ParameterDeclarationList</b> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">ExtKR_ParameterDeclarationListSyntax</a> *&amp;paramList)</td></tr>
<tr class="separator:abfebd7cb549b9f18013a867a116fe5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e88f8ed7430c163f883e00fea2c4f05"><td class="memItemLeft" align="right" valign="top"><a id="a3e88f8ed7430c163f883e00fea2c4f05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtKR_ParameterDeclaration</b> (<a class="el" href="classpsy_1_1_c_1_1_ext_k_r___parameter_declaration_syntax.html">ExtKR_ParameterDeclarationSyntax</a> *&amp;paramDecl)</td></tr>
<tr class="separator:a3e88f8ed7430c163f883e00fea2c4f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f9200c87d2047755f3f87f463649bb"><td class="memItemLeft" align="right" valign="top"><a id="ae3f9200c87d2047755f3f87f463649bb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ignoreDeclarator</b> ()</td></tr>
<tr class="separator:ae3f9200c87d2047755f3f87f463649bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20c6560846dfdce321f40d5ccc1ff88"><td class="memItemLeft" align="right" valign="top"><a id="ae20c6560846dfdce321f40d5ccc1ff88"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ignoreDeclarationOrDefinition</b> ()</td></tr>
<tr class="separator:ae20c6560846dfdce321f40d5ccc1ff88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f54547672aab5301e16f90c8dafd06"><td class="memItemLeft" align="right" valign="top"><a id="a72f54547672aab5301e16f90c8dafd06"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ignoreMemberDeclaration</b> ()</td></tr>
<tr class="separator:a72f54547672aab5301e16f90c8dafd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83215dc8ea2ef05f008fcce5d384ed5d"><td class="memItemLeft" align="right" valign="top"><a id="a83215dc8ea2ef05f008fcce5d384ed5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ignoreStatement</b> ()</td></tr>
<tr class="separator:a83215dc8ea2ef05f008fcce5d384ed5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654de5bf8a628617cbedee32e87ee8ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a654de5bf8a628617cbedee32e87ee8ed">parseDeclarationSpecifiers</a> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;specList)</td></tr>
<tr class="separator:a654de5bf8a628617cbedee32e87ee8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856f16692fa6a40954209aadcaf5f2ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a856f16692fa6a40954209aadcaf5f2ef">parseSpecifierQualifierList</a> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;specList)</td></tr>
<tr class="separator:a856f16692fa6a40954209aadcaf5f2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d0dd72e0e390a9df3b022cdd0b6d98"><td class="memTemplParams" colspan="2">template&lt;class SpecT &gt; </td></tr>
<tr class="memitem:a75d0dd72e0e390a9df3b022cdd0b6d98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a75d0dd72e0e390a9df3b022cdd0b6d98">parseTrivialSpecifier_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;spec, SyntaxKind specK)</td></tr>
<tr class="separator:a75d0dd72e0e390a9df3b022cdd0b6d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b5303fb92cf6d06b23186826f25557"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a51b5303fb92cf6d06b23186826f25557">parseAlignmentSpecifier_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;spec)</td></tr>
<tr class="separator:a51b5303fb92cf6d06b23186826f25557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b1cbb11491962e403152c633f466fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a65b1cbb11491962e403152c633f466fa">parseExtGNU_Typeof_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;spec)</td></tr>
<tr class="separator:a65b1cbb11491962e403152c633f466fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cd47a5dd734b69ffcca5dc5942991c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ae0cd47a5dd734b69ffcca5dc5942991c">parseTypedefName_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;spec)</td></tr>
<tr class="separator:ae0cd47a5dd734b69ffcca5dc5942991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d8468cdb2252fc7e0d3a1d473b7fce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#af6d8468cdb2252fc7e0d3a1d473b7fce">parseAtomiceTypeSpecifier_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;spec)</td></tr>
<tr class="separator:af6d8468cdb2252fc7e0d3a1d473b7fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79804621659d99a94b3da3a14580f03"><td class="memTemplParams" colspan="2">template&lt;class TypeDeclT &gt; </td></tr>
<tr class="memitem:ab79804621659d99a94b3da3a14580f03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ab79804621659d99a94b3da3a14580f03">parseTagTypeSpecifier_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;decl, <a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;spec, SyntaxKind declK, SyntaxKind specK, bool(Parser::*parseMember)(<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;))</td></tr>
<tr class="separator:ab79804621659d99a94b3da3a14580f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba42192dd32efea91d59587234bd29d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a2ba42192dd32efea91d59587234bd29d">parseExtGNU_AttributeSpecifierList_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;specList)</td></tr>
<tr class="separator:a2ba42192dd32efea91d59587234bd29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14b91b581cf17a7b22926abf0fd8b6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#aa14b91b581cf17a7b22926abf0fd8b6f">parseExtGNU_AttributeSpecifier_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;spec)</td></tr>
<tr class="separator:aa14b91b581cf17a7b22926abf0fd8b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accacaa73c9d4941adf371fac27dd6c76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#accacaa73c9d4941adf371fac27dd6c76">parseExtGNU_AttributeList</a> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExtGNU_AttributeListSyntax</a> *&amp;attrList)</td></tr>
<tr class="separator:accacaa73c9d4941adf371fac27dd6c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7739c0ecde34eb30359475391e5097"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#aac7739c0ecde34eb30359475391e5097">parseExtGNU_Attribute</a> (<a class="el" href="classpsy_1_1_c_1_1_ext_g_n_u___attribute_syntax.html">ExtGNU_AttributeSyntax</a> *&amp;attr)</td></tr>
<tr class="separator:aac7739c0ecde34eb30359475391e5097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b528dca3199f47521f56a19b70e46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a5c0b528dca3199f47521f56a19b70e46">parseExtGNU_AttributeArguments</a> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;exprList)</td></tr>
<tr class="separator:a5c0b528dca3199f47521f56a19b70e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66366cb197d2905a9aa91040cd4faf75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a66366cb197d2905a9aa91040cd4faf75">parseExtGNU_AttributeArgumentsLLVM</a> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;exprList)</td></tr>
<tr class="separator:a66366cb197d2905a9aa91040cd4faf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23e1aa38c168e1d1aa5746f45479fa6"><td class="memItemLeft" align="right" valign="top"><a id="aa23e1aa38c168e1d1aa5746f45479fa6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmLabel_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;attr)</td></tr>
<tr class="separator:aa23e1aa38c168e1d1aa5746f45479fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fd7d758424760caae318d9131a1789"><td class="memItemLeft" align="right" valign="top"><a id="a29fd7d758424760caae318d9131a1789"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtPSY_QuantifiedTypeSpecifier_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;spec)</td></tr>
<tr class="separator:a29fd7d758424760caae318d9131a1789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac892767b7c19fd657cc97897b94fa328"><td class="memItemLeft" align="right" valign="top"><a id="ac892767b7c19fd657cc97897b94fa328"></a>
IdentifierRole&#160;</td><td class="memItemRight" valign="bottom"><b>determineIdentifierRole</b> (bool seenType) const</td></tr>
<tr class="separator:ac892767b7c19fd657cc97897b94fa328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6bb72a88ca389113240fa221e9d6c9"><td class="memItemLeft" align="right" valign="top"><a id="ada6bb72a88ca389113240fa221e9d6c9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseAbstractDeclarator</b> (<a class="el" href="classpsy_1_1_c_1_1_declarator_syntax.html">DeclaratorSyntax</a> *&amp;decltor)</td></tr>
<tr class="separator:ada6bb72a88ca389113240fa221e9d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7311299cfe8d80acaf489565beba4602"><td class="memItemLeft" align="right" valign="top"><a id="a7311299cfe8d80acaf489565beba4602"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseDeclarator</b> (<a class="el" href="classpsy_1_1_c_1_1_declarator_syntax.html">DeclaratorSyntax</a> *&amp;decltor, <a class="el" href="classpsy_1_1_c_1_1_parser.html#a846861f4315842abc4c85dd23f57b3dd">DeclarationScope</a> declScope)</td></tr>
<tr class="separator:a7311299cfe8d80acaf489565beba4602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fa771ff2adb70155e731bc0801dcb4"><td class="memItemLeft" align="right" valign="top"><a id="a63fa771ff2adb70155e731bc0801dcb4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseDeclarator</b> (<a class="el" href="classpsy_1_1_c_1_1_declarator_syntax.html">DeclaratorSyntax</a> *&amp;decltor, <a class="el" href="classpsy_1_1_c_1_1_parser.html#a846861f4315842abc4c85dd23f57b3dd">DeclarationScope</a> declScope, DeclaratorVariety decltorVariety)</td></tr>
<tr class="separator:a63fa771ff2adb70155e731bc0801dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace756209cf9e8973e7a633516dacdac3"><td class="memItemLeft" align="right" valign="top"><a id="ace756209cf9e8973e7a633516dacdac3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseDirectDeclarator</b> (<a class="el" href="classpsy_1_1_c_1_1_declarator_syntax.html">DeclaratorSyntax</a> *&amp;decltor, <a class="el" href="classpsy_1_1_c_1_1_parser.html#a846861f4315842abc4c85dd23f57b3dd">DeclarationScope</a> declScope, DeclaratorVariety decltorVariety, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *attrList)</td></tr>
<tr class="separator:ace756209cf9e8973e7a633516dacdac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087a0d827dc0477b83cf393fd2434414"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a087a0d827dc0477b83cf393fd2434414">parseDirectDeclaratorSuffix</a> (<a class="el" href="classpsy_1_1_c_1_1_declarator_syntax.html">DeclaratorSyntax</a> *&amp;decltor, <a class="el" href="classpsy_1_1_c_1_1_parser.html#a846861f4315842abc4c85dd23f57b3dd">DeclarationScope</a> declScope, DeclaratorVariety decltorVariety, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *attrList, <a class="el" href="classpsy_1_1_c_1_1_declarator_syntax.html">DeclaratorSyntax</a> *innerDecltor)</td></tr>
<tr class="separator:a087a0d827dc0477b83cf393fd2434414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e739f6e335bc4e7c2034ab5918dc62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a98e739f6e335bc4e7c2034ab5918dc62">parseTypeQualifiersAndAttributes</a> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;specList)</td></tr>
<tr class="separator:a98e739f6e335bc4e7c2034ab5918dc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4712d7d67611f10c720d5b8a548991a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ae4712d7d67611f10c720d5b8a548991a">parseInitializer</a> (<a class="el" href="classpsy_1_1_c_1_1_initializer_syntax.html">InitializerSyntax</a> *&amp;init)</td></tr>
<tr class="separator:ae4712d7d67611f10c720d5b8a548991a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89c6c8ba6411780467a5c02229fd8a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#aa89c6c8ba6411780467a5c02229fd8a9">parseExpressionInitializer</a> (<a class="el" href="classpsy_1_1_c_1_1_initializer_syntax.html">InitializerSyntax</a> *&amp;init)</td></tr>
<tr class="separator:aa89c6c8ba6411780467a5c02229fd8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87853005cb3ee51cdf5a611b87e8c1c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a87853005cb3ee51cdf5a611b87e8c1c1">parseBraceEnclosedInitializer_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_initializer_syntax.html">InitializerSyntax</a> *&amp;init)</td></tr>
<tr class="separator:a87853005cb3ee51cdf5a611b87e8c1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d4fa6751890e00b9e0ed5a99cfc5f6"><td class="memItemLeft" align="right" valign="top"><a id="a77d4fa6751890e00b9e0ed5a99cfc5f6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseInitializerList</b> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">InitializerListSyntax</a> *&amp;initList)</td></tr>
<tr class="separator:a77d4fa6751890e00b9e0ed5a99cfc5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0dea7ea03eb8ee728741ddeb71ee23"><td class="memItemLeft" align="right" valign="top"><a id="a3f0dea7ea03eb8ee728741ddeb71ee23"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseInitializerListItem</b> (<a class="el" href="classpsy_1_1_c_1_1_initializer_syntax.html">InitializerSyntax</a> *&amp;init, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">InitializerListSyntax</a> *&amp;initList)</td></tr>
<tr class="separator:a3f0dea7ea03eb8ee728741ddeb71ee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b13248a456c8bf31db36af66548111c"><td class="memItemLeft" align="right" valign="top"><a id="a6b13248a456c8bf31db36af66548111c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseDesignatedInitializer_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_initializer_syntax.html">InitializerSyntax</a> *&amp;init, bool(Parser::*parseDesig)(<a class="el" href="classpsy_1_1_c_1_1_designator_syntax.html">DesignatorSyntax</a> *&amp;desig))</td></tr>
<tr class="separator:a6b13248a456c8bf31db36af66548111c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe82ea7fed5b470f0f1513ee0bfb13a"><td class="memItemLeft" align="right" valign="top"><a id="a7fe82ea7fed5b470f0f1513ee0bfb13a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseDesignatorList_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">DesignatorListSyntax</a> *&amp;desigList, bool(Parser::*parseDesig)(<a class="el" href="classpsy_1_1_c_1_1_designator_syntax.html">DesignatorSyntax</a> *&amp;desig))</td></tr>
<tr class="separator:a7fe82ea7fed5b470f0f1513ee0bfb13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8462ec4cdfe94a764b31247ff1af2b2f"><td class="memItemLeft" align="right" valign="top"><a id="a8462ec4cdfe94a764b31247ff1af2b2f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseFieldDesignator_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_designator_syntax.html">DesignatorSyntax</a> *&amp;desig)</td></tr>
<tr class="separator:a8462ec4cdfe94a764b31247ff1af2b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53b3a0683cc6c52e2a6461f68e9e2f6"><td class="memItemLeft" align="right" valign="top"><a id="ab53b3a0683cc6c52e2a6461f68e9e2f6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseArrayDesignator_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_designator_syntax.html">DesignatorSyntax</a> *&amp;desig)</td></tr>
<tr class="separator:ab53b3a0683cc6c52e2a6461f68e9e2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee404b7502eb7a95a754b6eec1c7ca8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a6ee404b7502eb7a95a754b6eec1c7ca8">parseOffsetOfDesignator</a> (<a class="el" href="classpsy_1_1_c_1_1_designator_syntax.html">DesignatorSyntax</a> *&amp;desig)</td></tr>
<tr class="separator:a6ee404b7502eb7a95a754b6eec1c7ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fa51ec44f6740ef75ba8aa414141c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">parseExpression</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a42fa51ec44f6740ef75ba8aa414141c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1708b29fc61bbd0cfc008d98e27cf267"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a1708b29fc61bbd0cfc008d98e27cf267">parseIdentifierName</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a1708b29fc61bbd0cfc008d98e27cf267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608ea6025178276dd81cc1d678ad1960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a608ea6025178276dd81cc1d678ad1960">parseIdentifierName_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a608ea6025178276dd81cc1d678ad1960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121eab4eee45d6879ffaccc51f90d8f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a121eab4eee45d6879ffaccc51f90d8f9">parsePredefinedName_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a121eab4eee45d6879ffaccc51f90d8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc40061af8b5536b72ce248528836eb3"><td class="memTemplParams" colspan="2">template&lt;class ExprT &gt; </td></tr>
<tr class="memitem:afc40061af8b5536b72ce248528836eb3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#afc40061af8b5536b72ce248528836eb3">parseConstant</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr, SyntaxKind exprK)</td></tr>
<tr class="separator:afc40061af8b5536b72ce248528836eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790a7349983337778d744ceaff46a231"><td class="memTemplParams" colspan="2">template&lt;class ExprT &gt; </td></tr>
<tr class="memitem:a790a7349983337778d744ceaff46a231"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a790a7349983337778d744ceaff46a231">parseConstant_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr, SyntaxKind exprK)</td></tr>
<tr class="separator:a790a7349983337778d744ceaff46a231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947584f91b96f8b7e8c7d5412b3f03ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a947584f91b96f8b7e8c7d5412b3f03ab">parseStringLiteral</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a947584f91b96f8b7e8c7d5412b3f03ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fafcb6b7a9448c844ea9903375decf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a5fafcb6b7a9448c844ea9903375decf1">parseStringLiteral_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a5fafcb6b7a9448c844ea9903375decf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d35e7fd7baddf42e75284a2e4521efe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a5d35e7fd7baddf42e75284a2e4521efe">parseParenthesizedExpression_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a5d35e7fd7baddf42e75284a2e4521efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b71d18d5770c42c6ee4e47bf06e7ff6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a7b71d18d5770c42c6ee4e47bf06e7ff6">parseGenericSelectionExpression_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a7b71d18d5770c42c6ee4e47bf06e7ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb688db8fed0523d465fbffb84a0a0db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#acb688db8fed0523d465fbffb84a0a0db">parseGenericAssociationList</a> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">GenericAssociationListSyntax</a> *&amp;assocList)</td></tr>
<tr class="separator:acb688db8fed0523d465fbffb84a0a0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d260579a11e6a8d5e75766aa817a90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a36d260579a11e6a8d5e75766aa817a90">parseGenericAssociation</a> (<a class="el" href="classpsy_1_1_c_1_1_generic_association_syntax.html">GenericAssociationSyntax</a> *&amp;assoc, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">GenericAssociationListSyntax</a> *&amp;assocList)</td></tr>
<tr class="separator:a36d260579a11e6a8d5e75766aa817a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df4db8c4d6bec1e0243b33fde6b6d0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a0df4db8c4d6bec1e0243b33fde6b6d0a">parseExtGNU_StatementExpression_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a0df4db8c4d6bec1e0243b33fde6b6d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606d4dd254878aaa45b8b047e722d6b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a606d4dd254878aaa45b8b047e722d6b6">parseExtGNU_ComplexValuedExpression_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr, SyntaxKind exprK)</td></tr>
<tr class="separator:a606d4dd254878aaa45b8b047e722d6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc508cede9cc1d63a0ee0e84ea3c0e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#aacc508cede9cc1d63a0ee0e84ea3c0e0">parseExpressionWithPrecedencePostfix</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:aacc508cede9cc1d63a0ee0e84ea3c0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cd1483b6b9d3b7557cb810e4e330f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ac0cd1483b6b9d3b7557cb810e4e330f4">parsePostfixExpression_AtFollowOfPrimary</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:ac0cd1483b6b9d3b7557cb810e4e330f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4f2305ff6283b2501bbafba0bde622"><td class="memTemplParams" colspan="2">template&lt;class ExprT &gt; </td></tr>
<tr class="memitem:a4b4f2305ff6283b2501bbafba0bde622"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a4b4f2305ff6283b2501bbafba0bde622">parsePostfixExpression_AtFollowOfPrimary</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr, SyntaxKind exprK, std::function&lt; bool(ExprT *&amp;)&gt; parsePostfix)</td></tr>
<tr class="separator:a4b4f2305ff6283b2501bbafba0bde622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c388ae7bdfbe655e0fac12f6873b227"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a7c388ae7bdfbe655e0fac12f6873b227">parseCallArguments</a> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;exprList)</td></tr>
<tr class="separator:a7c388ae7bdfbe655e0fac12f6873b227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221a66f91e7f68acf1a3248a823f4f14"><td class="memItemLeft" align="right" valign="top"><a id="a221a66f91e7f68acf1a3248a823f4f14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseCallArgument</b> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;exprList)</td></tr>
<tr class="separator:a221a66f91e7f68acf1a3248a823f4f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae987c564018dc5e8daa2a3f13967ccde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ae987c564018dc5e8daa2a3f13967ccde">parseCompoundLiteral_AtOpenParen</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:ae987c564018dc5e8daa2a3f13967ccde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb21ec1874ccc125a7c48ff22c31f33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a6eb21ec1874ccc125a7c48ff22c31f33">parseCompoundLiteral_AtOpenBrace</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr, LexedTokens::IndexType openParenTkIdx, <a class="el" href="classpsy_1_1_c_1_1_type_name_syntax.html">TypeNameSyntax</a> *typeName, LexedTokens::IndexType closeParenTkIdx)</td></tr>
<tr class="separator:a6eb21ec1874ccc125a7c48ff22c31f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb496d301922ab2ad3a0b283e3ba24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ac6bb496d301922ab2ad3a0b283e3ba24">parseVAArgumentExpression_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:ac6bb496d301922ab2ad3a0b283e3ba24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539dbfa51bbc89613f9bac075e8ab58d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a539dbfa51bbc89613f9bac075e8ab58d">parseOffsetOfExpression_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a539dbfa51bbc89613f9bac075e8ab58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6eafb27cae97bc912b2af102d1fa65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a8b6eafb27cae97bc912b2af102d1fa65">parseExtGNU_ChooseExpression_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a8b6eafb27cae97bc912b2af102d1fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72841484d25c289e096620b716898425"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a72841484d25c289e096620b716898425">parseExpressionWithPrecedenceUnary</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a72841484d25c289e096620b716898425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546ff2bacd3f620c2ea4397e1ad9286a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a546ff2bacd3f620c2ea4397e1ad9286a">parsePrefixUnaryExpression_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr, SyntaxKind exprK, bool(Parser::*parseOperand)(<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;))</td></tr>
<tr class="separator:a546ff2bacd3f620c2ea4397e1ad9286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500984502247fb47f00d410b506bbe92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a500984502247fb47f00d410b506bbe92">parseTypeTraitExpression_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr, SyntaxKind exprK)</td></tr>
<tr class="separator:a500984502247fb47f00d410b506bbe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4157d96aeb0c54866129a82e7ba8c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a1b4157d96aeb0c54866129a82e7ba8c1">parseExpressionWithPrecedenceCast</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a1b4157d96aeb0c54866129a82e7ba8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3802e9d69bc5d50f65153f6134a5d7"><td class="memItemLeft" align="right" valign="top"><a id="a0f3802e9d69bc5d50f65153f6134a5d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseCompoundLiteralOrCastExpression_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a0f3802e9d69bc5d50f65153f6134a5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aad73d601d3f6a3d4eb67db08ee9d50"><td class="memItemLeft" align="right" valign="top"><a id="a1aad73d601d3f6a3d4eb67db08ee9d50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>maybeAmbiguateCastExpression</b> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a1aad73d601d3f6a3d4eb67db08ee9d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7026710387deb1cbb42df4cf10cbaf7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#aa7026710387deb1cbb42df4cf10cbaf7">parseExpressionWithPrecedenceMultiplicative</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:aa7026710387deb1cbb42df4cf10cbaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307888d9ef76bbeddf92c65507b43582"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a307888d9ef76bbeddf92c65507b43582">parseExpressionWithPrecedenceAdditive</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a307888d9ef76bbeddf92c65507b43582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade33702c958c7b7088cc18dca9860f06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ade33702c958c7b7088cc18dca9860f06">parseExpressionWithPrecedenceShift</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:ade33702c958c7b7088cc18dca9860f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef23fa347ab61074c02384d8e6a2e8b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#aef23fa347ab61074c02384d8e6a2e8b4">parseExpressionWithPrecedenceRelational</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:aef23fa347ab61074c02384d8e6a2e8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e10aeffe0834cf1346492b551faab1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a59e10aeffe0834cf1346492b551faab1">parseExpressionWithPrecedenceEquality</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a59e10aeffe0834cf1346492b551faab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40684485112192872a11c8d4a4148bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#ac40684485112192872a11c8d4a4148bf">parseExpressionWithPrecedenceBitwiseAND</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:ac40684485112192872a11c8d4a4148bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa139257060635e260f72bea66935d78e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#aa139257060635e260f72bea66935d78e">parseExpressionWithPrecedenceBitwiseXOR</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:aa139257060635e260f72bea66935d78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0599cabb52e49f01d45fa40cc0f5372c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a0599cabb52e49f01d45fa40cc0f5372c">parseExpressionWithPrecedenceBitwiseOR</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a0599cabb52e49f01d45fa40cc0f5372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1269429f313fd3bd940ec5b5977e40e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a1269429f313fd3bd940ec5b5977e40e6">parseExpressionWithPrecedenceLogicalAND</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a1269429f313fd3bd940ec5b5977e40e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8c30961d6899f033a1350b242a51e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a6a8c30961d6899f033a1350b242a51e0">parseExpressionWithPrecedenceLogicalOR</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a6a8c30961d6899f033a1350b242a51e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072c2948806f4d349afd6ec6be7c9940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a072c2948806f4d349afd6ec6be7c9940">parseExpressionWithPrecedenceConditional</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a072c2948806f4d349afd6ec6be7c9940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399b45d275b9101bc55bc23e5824708f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a399b45d275b9101bc55bc23e5824708f">parseExpressionWithPrecedenceAssignment</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a399b45d275b9101bc55bc23e5824708f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298005a4530d0e5436c34392cc9c0e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a298005a4530d0e5436c34392cc9c0e9d">parseExpressionWithPrecedenceComma</a> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr)</td></tr>
<tr class="separator:a298005a4530d0e5436c34392cc9c0e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094d8fe381bb76555d50a0b0829ae6a0"><td class="memItemLeft" align="right" valign="top"><a id="a094d8fe381bb76555d50a0b0829ae6a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseNAryExpression</b> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;expr, std::uint8_t cutoffPrecedence)</td></tr>
<tr class="separator:a094d8fe381bb76555d50a0b0829ae6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b919945da37459456dfdde35a7622e6"><td class="memItemLeft" align="right" valign="top"><a id="a6b919945da37459456dfdde35a7622e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseNAryExpression_AtOperator</b> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;baseExpr, std::uint8_t cutoffPrecedence)</td></tr>
<tr class="separator:a6b919945da37459456dfdde35a7622e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3882121b7f487b37a52597b122cc5721"><td class="memTemplParams" colspan="2"><a id="a3882121b7f487b37a52597b122cc5721"></a>
template&lt;class NodeT &gt; </td></tr>
<tr class="memitem:a3882121b7f487b37a52597b122cc5721"><td class="memTemplItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill_LeftOperandInfixOperatorRightOperand_MIXIN</b> (NodeT *expr, <a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *left, LexedTokens::IndexType opTkIdx, <a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *right)</td></tr>
<tr class="separator:a3882121b7f487b37a52597b122cc5721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1522f05e48327c5cc6e297e0fe7318a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a1522f05e48327c5cc6e297e0fe7318a7">parseStatement</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:a1522f05e48327c5cc6e297e0fe7318a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aec309fbe754fc1d72fc4140d5d3a00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a3aec309fbe754fc1d72fc4140d5d3a00">parseCompoundStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:a3aec309fbe754fc1d72fc4140d5d3a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca738a7216dd278103751784a315f93"><td class="memItemLeft" align="right" valign="top"><a id="a6ca738a7216dd278103751784a315f93"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseDeclarationStatement</b> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, bool(Parser::*parseDecl)(<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;))</td></tr>
<tr class="separator:a6ca738a7216dd278103751784a315f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c8ec09ba416869936ecaa1ea73bfaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a29c8ec09ba416869936ecaa1ea73bfaa">parseExpressionStatement</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt)</td></tr>
<tr class="separator:a29c8ec09ba416869936ecaa1ea73bfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daa8904b5786d6d72452e33c631f495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a2daa8904b5786d6d72452e33c631f495">parseLabeledStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:a2daa8904b5786d6d72452e33c631f495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986ed810d3f63d77690892816f109efc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a986ed810d3f63d77690892816f109efc">parseIfStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:a986ed810d3f63d77690892816f109efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0069b5e560093b7ac850f75a2ea2ef2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a0069b5e560093b7ac850f75a2ea2ef2d">parseSwitchStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:a0069b5e560093b7ac850f75a2ea2ef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bb57dcb339b6a72d4d456666f77b71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a15bb57dcb339b6a72d4d456666f77b71">parseWhileStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:a15bb57dcb339b6a72d4d456666f77b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe3a21e96d9bd6b4359b17e2a72fedb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#affe3a21e96d9bd6b4359b17e2a72fedb">parseDoStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:affe3a21e96d9bd6b4359b17e2a72fedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabca754b1198b388214ac0d27ca27c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#aaabca754b1198b388214ac0d27ca27c2">parseForStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:aaabca754b1198b388214ac0d27ca27c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff926c1309ef3671e80efa2335d71381"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#aff926c1309ef3671e80efa2335d71381">parseGotoStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt)</td></tr>
<tr class="separator:aff926c1309ef3671e80efa2335d71381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc53dc416ff348229c3abc0d3b2d589"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a1dc53dc416ff348229c3abc0d3b2d589">parseContinueStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:a1dc53dc416ff348229c3abc0d3b2d589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7544f9898e79f4d8172a68754477d654"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a7544f9898e79f4d8172a68754477d654">parseBreakStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt, StatementContext stmtCtx)</td></tr>
<tr class="separator:a7544f9898e79f4d8172a68754477d654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd5a30595011ebd334e17c71063d1f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#acfd5a30595011ebd334e17c71063d1f3">parseReturnStatement_AtFirst</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt)</td></tr>
<tr class="separator:acfd5a30595011ebd334e17c71063d1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b004a81758a91d0eef8408a7597b39e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a4b004a81758a91d0eef8408a7597b39e">parseExtGNU_AsmStatement</a> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt)</td></tr>
<tr class="separator:a4b004a81758a91d0eef8408a7597b39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858461fd8675e12abac8210ae5ce4318"><td class="memItemLeft" align="right" valign="top"><a id="a858461fd8675e12abac8210ae5ce4318"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmQualifiers</b> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;specList)</td></tr>
<tr class="separator:a858461fd8675e12abac8210ae5ce4318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be3be085be14b5406d6571c94568af0"><td class="memItemLeft" align="right" valign="top"><a id="a3be3be085be14b5406d6571c94568af0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmOperands</b> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExtGNU_AsmOperandListSyntax</a> *&amp;asmOprdsList)</td></tr>
<tr class="separator:a3be3be085be14b5406d6571c94568af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7e6d4dab11409fb207c221e1a33f5e"><td class="memItemLeft" align="right" valign="top"><a id="a2b7e6d4dab11409fb207c221e1a33f5e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmOutputOperand_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_ext_g_n_u___asm_operand_syntax.html">ExtGNU_AsmOperandSyntax</a> *&amp;asmOprd, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExtGNU_AsmOperandListSyntax</a> *&amp;)</td></tr>
<tr class="separator:a2b7e6d4dab11409fb207c221e1a33f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426fc7552f153296bcb3bd7e698b6b1c"><td class="memItemLeft" align="right" valign="top"><a id="a426fc7552f153296bcb3bd7e698b6b1c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmInputOperand_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_ext_g_n_u___asm_operand_syntax.html">ExtGNU_AsmOperandSyntax</a> *&amp;asmOprd, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExtGNU_AsmOperandListSyntax</a> *&amp;)</td></tr>
<tr class="separator:a426fc7552f153296bcb3bd7e698b6b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e819cb23190339db10f75ff7ded82a3"><td class="memItemLeft" align="right" valign="top"><a id="a8e819cb23190339db10f75ff7ded82a3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmOperand_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_ext_g_n_u___asm_operand_syntax.html">ExtGNU_AsmOperandSyntax</a> *&amp;asmOprd, SyntaxKind oprdK)</td></tr>
<tr class="separator:a8e819cb23190339db10f75ff7ded82a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266279ae526b4422b2375735ca4fea98"><td class="memItemLeft" align="right" valign="top"><a id="a266279ae526b4422b2375735ca4fea98"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmClobbers</b> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;clobList)</td></tr>
<tr class="separator:a266279ae526b4422b2375735ca4fea98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ea6656debc45fb0c88f4c5e2d964c6"><td class="memItemLeft" align="right" valign="top"><a id="a99ea6656debc45fb0c88f4c5e2d964c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmClobber_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;clob, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;clobList)</td></tr>
<tr class="separator:a99ea6656debc45fb0c88f4c5e2d964c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586750512d910b6f30c2478f52d84415"><td class="memItemLeft" align="right" valign="top"><a id="a586750512d910b6f30c2478f52d84415"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmGotoLabels</b> (<a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;labelList)</td></tr>
<tr class="separator:a586750512d910b6f30c2478f52d84415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae667b8e3770dc1fa7fb534960517c47c"><td class="memItemLeft" align="right" valign="top"><a id="ae667b8e3770dc1fa7fb534960517c47c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseExtGNU_AsmGotoLabel_AtFirst</b> (<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;label, <a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;)</td></tr>
<tr class="separator:ae667b8e3770dc1fa7fb534960517c47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32e7ad32d74aed1f6a23a808921facf"><td class="memItemLeft" align="right" valign="top"><a id="aa32e7ad32d74aed1f6a23a808921facf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>maybeAmbiguateStatement</b> (<a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;stmt)</td></tr>
<tr class="separator:aa32e7ad32d74aed1f6a23a808921facf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68578c0f6d7095c887c13e3f6b6fbfe8"><td class="memItemLeft" align="right" valign="top"><a id="a68578c0f6d7095c887c13e3f6b6fbfe8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkStatementParse</b> (bool stmtParsed)</td></tr>
<tr class="separator:a68578c0f6d7095c887c13e3f6b6fbfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac937ae64f044c3c45a23d1fc406cb0b5"><td class="memTemplParams" colspan="2"><a id="ac937ae64f044c3c45a23d1fc406cb0b5"></a>
template&lt;class NodeT , class NodeListT &gt; </td></tr>
<tr class="memitem:ac937ae64f044c3c45a23d1fc406cb0b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseCommaSeparatedItems</b> (NodeListT *&amp;nodeList, bool(Parser::*parseItem)(NodeT *&amp;node, NodeListT *&amp;nodeList))</td></tr>
<tr class="separator:ac937ae64f044c3c45a23d1fc406cb0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8177335140e90abb517a0fe696bbaf1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a8177335140e90abb517a0fe696bbaf1e">parseTypeName</a> (<a class="el" href="classpsy_1_1_c_1_1_type_name_syntax.html">TypeNameSyntax</a> *&amp;typeName)</td></tr>
<tr class="separator:a8177335140e90abb517a0fe696bbaf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ab3499f885612b54a3e7713378bcb9"><td class="memItemLeft" align="right" valign="top"><a id="a86ab3499f885612b54a3e7713378bcb9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parseParenthesizedTypeNameOrExpression</b> (<a class="el" href="classpsy_1_1_c_1_1_type_reference_syntax.html">TypeReferenceSyntax</a> *&amp;tyRef)</td></tr>
<tr class="separator:a86ab3499f885612b54a3e7713378bcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcdd708dc71b2cd6943bd88f661c96e"><td class="memItemLeft" align="right" valign="top"><a id="aabcdd708dc71b2cd6943bd88f661c96e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>maybeAmbiguateTypeReference</b> (<a class="el" href="classpsy_1_1_c_1_1_type_reference_syntax.html">TypeReferenceSyntax</a> *&amp;tyRef)</td></tr>
<tr class="separator:aabcdd708dc71b2cd6943bd88f661c96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad07c3a07470567e4201f19e89f4f6ad5"><td class="memItemLeft" align="right" valign="top"><a id="ad07c3a07470567e4201f19e89f4f6ad5"></a>
<a class="el" href="classpsy_1_1_c_1_1_memory_pool.html">MemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pool_</b></td></tr>
<tr class="separator:ad07c3a07470567e4201f19e89f4f6ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94e1c7e03f3ebcab5adc4bb72a201b4"><td class="memItemLeft" align="right" valign="top"><a id="aa94e1c7e03f3ebcab5adc4bb72a201b4"></a>
<a class="el" href="classpsy_1_1_c_1_1_syntax_tree.html">SyntaxTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>tree_</b></td></tr>
<tr class="separator:aa94e1c7e03f3ebcab5adc4bb72a201b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa511391853c286459e1874a3cdf8727b"><td class="memItemLeft" align="right" valign="top"><a id="aa511391853c286459e1874a3cdf8727b"></a>
const <a class="el" href="structpsy_1_1_c_1_1_parser_1_1_backtracker.html">Backtracker</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>backtracker_</b></td></tr>
<tr class="separator:aa511391853c286459e1874a3cdf8727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a7aaee0a76ceffa853a00ec74d033"><td class="memItemLeft" align="right" valign="top"><a id="a926a7aaee0a76ceffa853a00ec74d033"></a>
<a class="el" href="structpsy_1_1_c_1_1_parser_1_1_diagnostics_reporter.html">DiagnosticsReporter</a>&#160;</td><td class="memItemRight" valign="bottom"><b>diagReporter_</b></td></tr>
<tr class="separator:a926a7aaee0a76ceffa853a00ec74d033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5649aa2adc980bc3316f3bfa19340ebc"><td class="memItemLeft" align="right" valign="top"><a id="a5649aa2adc980bc3316f3bfa19340ebc"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>curTkIdx_</b></td></tr>
<tr class="separator:a5649aa2adc980bc3316f3bfa19340ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cb347522d0da292dd4b300d33a3f14"><td class="memItemLeft" align="right" valign="top"><a id="a00cb347522d0da292dd4b300d33a3f14"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>depthOfExprs_</b></td></tr>
<tr class="separator:a00cb347522d0da292dd4b300d33a3f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e45ba4e922d235a813422ace041a96"><td class="memItemLeft" align="right" valign="top"><a id="a78e45ba4e922d235a813422ace041a96"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>depthOfStmts_</b></td></tr>
<tr class="separator:a78e45ba4e922d235a813422ace041a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af8f8d76e5cfc64c1c5a935995b139e3d"><td class="memItemLeft" align="right" valign="top"><a id="af8f8d76e5cfc64c1c5a935995b139e3d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ParserTester</b></td></tr>
<tr class="separator:af8f8d76e5cfc64c1c5a935995b139e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4772e4983004614963cc559795a1bfd2"><td class="memItemLeft" align="right" valign="top"><a id="a4772e4983004614963cc559795a1bfd2"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>Backtracker</b></td></tr>
<tr class="separator:a4772e4983004614963cc559795a1bfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1299a195ad5bc4fff3e7f4b14bdd253d"><td class="memItemLeft" align="right" valign="top"><a id="a1299a195ad5bc4fff3e7f4b14bdd253d"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>DiagnosticsReporter</b></td></tr>
<tr class="separator:a1299a195ad5bc4fff3e7f4b14bdd253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ecf80e09fe19570a6911d000152d3a"><td class="memItemLeft" align="right" valign="top"><a id="a95ecf80e09fe19570a6911d000152d3a"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>DepthControl</b></td></tr>
<tr class="separator:a95ecf80e09fe19570a6911d000152d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf67282bb197c3e4b3b97de805f9db5b"><td class="memItemLeft" align="right" valign="top"><a id="aaf67282bb197c3e4b3b97de805f9db5b"></a>
StatementContext&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (StatementContext a, StatementContext b)</td></tr>
<tr class="separator:aaf67282bb197c3e4b3b97de805f9db5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The C <a class="el" href="classpsy_1_1_c_1_1_parser.html" title="The C Parser class.">Parser</a> class. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a846861f4315842abc4c85dd23f57b3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846861f4315842abc4c85dd23f57b3dd">&#9670;&nbsp;</a></span>DeclarationScope</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpsy_1_1_c_1_1_parser.html#a846861f4315842abc4c85dd23f57b3dd">psy::C::Parser::DeclarationScope</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scope of a declaration. </p>
<dl class="section remark"><dt>Remarks</dt><dd>6.2.1-4 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abd4fbbe8241093a4db61be3ea92db204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4fbbe8241093a4db61be3ea92db204">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::match </td>
          <td>(</td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>expectedTkK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LexedTokens::IndexType *&#160;</td>
          <td class="paramname"><em>tkIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Match a token of the given kind. </p>

</div>
</div>
<a id="a50355ed345e8f786649ad3dd70a86df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50355ed345e8f786649ad3dd70a86df9">&#9670;&nbsp;</a></span>matchOrSkipTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::matchOrSkipTo </td>
          <td>(</td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>expectedTkK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LexedTokens::IndexType *&#160;</td>
          <td class="paramname"><em>tkIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Match a token of the given kind;; if the match was not successful, skip until a token of the given kind is found. </p>

</div>
</div>
<a id="a8f262cc92b22513be77df6427fac9a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f262cc92b22513be77df6427fac9a11">&#9670;&nbsp;</a></span>mightBacktrack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::mightBacktrack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the parser is in backtracking mode. </p>

</div>
</div>
<a id="a690edbb665fe0c75d0ae79faabf688b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690edbb665fe0c75d0ae79faabf688b5">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpsy_1_1_c_1_1_translation_unit_syntax.html">TranslationUnitSyntax</a> * Parser::parse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the syntax associated to the <a class="el" href="classpsy_1_1_c_1_1_syntax_tree.html" title="The SyntaxTree class.">SyntaxTree</a> used to construct <code>this</code> <a class="el" href="classpsy_1_1_c_1_1_parser.html" title="The C Parser class.">Parser</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classpsy_1_1_c_1_1_translation_unit_syntax.html" title="The TranslationUnitSyntax class.">TranslationUnitSyntax</a>. </dd></dl>

</div>
</div>
<a id="a51b5303fb92cf6d06b23186826f25557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b5303fb92cf6d06b23186826f25557">&#9670;&nbsp;</a></span>parseAlignmentSpecifier_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseAlignmentSpecifier_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>alignment-specifier</em>.</p>
<pre class="fragment">alignment-specifier:
    _Alignas ( type-name )
    _Alignas ( constant-expression )
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.5 </dd></dl>

</div>
</div>
<a id="af6d8468cdb2252fc7e0d3a1d473b7fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d8468cdb2252fc7e0d3a1d473b7fce">&#9670;&nbsp;</a></span>parseAtomiceTypeSpecifier_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseAtomiceTypeSpecifier_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>atomic-type-specifier</em>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.7.2.4 </dd></dl>

</div>
</div>
<a id="a87853005cb3ee51cdf5a611b87e8c1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87853005cb3ee51cdf5a611b87e8c1c1">&#9670;&nbsp;</a></span>parseBraceEnclosedInitializer_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseBraceEnclosedInitializer_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_initializer_syntax.html">InitializerSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>initializer</em> that is an <em>initializer-list</em> enclosed in braces.</p>
<p>In the adjusted grammar of <a class="el" href="classpsy_1_1_c_1_1_parser.html#ae4712d7d67611f10c720d5b8a548991a">Parser::parseInitializer</a>.</p>
<pre class="fragment">brace-enclosed-initializer
    { initializer-list }
    { initializer-list, }
</pre> 
</div>
</div>
<a id="a7544f9898e79f4d8172a68754477d654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7544f9898e79f4d8172a68754477d654">&#9670;&nbsp;</a></span>parseBreakStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseBreakStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>jump-statement</em> of the <code>break</code> <em>statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.6.3 </dd></dl>

</div>
</div>
<a id="a7c388ae7bdfbe655e0fac12f6873b227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c388ae7bdfbe655e0fac12f6873b227">&#9670;&nbsp;</a></span>parseCallArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseCallArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>exprList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>argument-expression-list</em>.</p>
<pre class="fragment">argument-expression-list:
    assignment-expression
    argument-expression-list , assignment-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.2 </dd></dl>

</div>
</div>
<a id="a6eb21ec1874ccc125a7c48ff22c31f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb21ec1874ccc125a7c48ff22c31f33">&#9670;&nbsp;</a></span>parseCompoundLiteral_AtOpenBrace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseCompoundLiteral_AtOpenBrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LexedTokens::IndexType&#160;</td>
          <td class="paramname"><em>openParenTkIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_type_name_syntax.html">TypeNameSyntax</a> *&#160;</td>
          <td class="paramname"><em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LexedTokens::IndexType&#160;</td>
          <td class="paramname"><em>closeParenTkIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>postfix-expression</em> that is a compound literal, with LA(1) at <code>{</code>.</p>
<p>In the adjusted grammar of <a class="el" href="classpsy_1_1_c_1_1_parser.html#ae987c564018dc5e8daa2a3f13967ccde">Parser::parseCompoundLiteral_AtOpenParen</a>.</p>
<pre class="fragment">compound-literal-at-open-brace:
   { initializer-list }
   { initializer-list, }
</pre> 
</div>
</div>
<a id="ae987c564018dc5e8daa2a3f13967ccde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae987c564018dc5e8daa2a3f13967ccde">&#9670;&nbsp;</a></span>parseCompoundLiteral_AtOpenParen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseCompoundLiteral_AtOpenParen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>postfix-expression</em> that is a compound literal, with LA(1) at <code></code>(.</p>
<p>In the adjusted grammar of <a class="el" href="classpsy_1_1_c_1_1_parser.html#aacc508cede9cc1d63a0ee0e84ea3c0e0">Parser::parseExpressionWithPrecedencePostfix</a>.</p>
<pre class="fragment">compound-literal-at-open-paren:
   ( type-name ) compound-literal-at-open-brace
</pre> 
</div>
</div>
<a id="a3aec309fbe754fc1d72fc4140d5d3a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aec309fbe754fc1d72fc4140d5d3a00">&#9670;&nbsp;</a></span>parseCompoundStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseCompoundStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>compound-statement</em>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.2 </dd></dl>

</div>
</div>
<a id="afc40061af8b5536b72ce248528836eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc40061af8b5536b72ce248528836eb3">&#9670;&nbsp;</a></span>parseConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExprT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template bool Parser::parseConstant&lt; <a class="el" href="classpsy_1_1_c_1_1_constant_expression_syntax.html">ConstantExpressionSyntax</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>exprK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>constant</em>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.4.4 and 6.5.1 </dd></dl>

</div>
</div>
<a id="a790a7349983337778d744ceaff46a231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790a7349983337778d744ceaff46a231">&#9670;&nbsp;</a></span>parseConstant_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExprT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template void Parser::parseConstant_AtFirst&lt; <a class="el" href="classpsy_1_1_c_1_1_constant_expression_syntax.html">ConstantExpressionSyntax</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>exprK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>constant</em>, with LA(1) at FIRST.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.4.4 and 6.5.1 </dd></dl>

</div>
</div>
<a id="a1dc53dc416ff348229c3abc0d3b2d589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc53dc416ff348229c3abc0d3b2d589">&#9670;&nbsp;</a></span>parseContinueStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseContinueStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>jump-statement</em> of the <code>continue</code> <em>statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.6.2 </dd></dl>

</div>
</div>
<a id="a728bbac45f245744d356e4001581f2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728bbac45f245744d356e4001581f2bb">&#9670;&nbsp;</a></span>parseDeclarationOrFunctionDefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseDeclarationOrFunctionDefinition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a (specifier-prefixed) <em>declaration</em> or a <em>function-definition</em>.</p>
<pre class="fragment">declaration:
    declaration-specifiers init-decltor-list_opt ;
    static_assert-declaration

function-definition:
    declaration-specifiers declarator declaration-list_opt compound-statement
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7, 6.9.1 </dd></dl>

</div>
</div>
<a id="a654de5bf8a628617cbedee32e87ee8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654de5bf8a628617cbedee32e87ee8ed">&#9670;&nbsp;</a></span>parseDeclarationSpecifiers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseDeclarationSpecifiers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>specList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>declaration-specifiers</em>.</p>
<pre class="fragment">declaration-specifiers:
    storage-class-specifier declaration-specifiers_opt
    type-specifier declaration-specifiers_opt
    type-qualifier declaration-specifiers_opt
    function-specifier declaration-specifiers_opt
    alignment-specifier declaration-specifiers_opt
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.1, 6.7.2, 6.7.3, 6.7.4, and 6.7.5 </dd></dl>

</div>
</div>
<a id="a087a0d827dc0477b83cf393fd2434414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087a0d827dc0477b83cf393fd2434414">&#9670;&nbsp;</a></span>parseDirectDeclaratorSuffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseDirectDeclaratorSuffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declarator_syntax.html">DeclaratorSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decltor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_parser.html#a846861f4315842abc4c85dd23f57b3dd">DeclarationScope</a>&#160;</td>
          <td class="paramname"><em>declScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeclaratorVariety&#160;</td>
          <td class="paramname"><em>decltorVariety</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&#160;</td>
          <td class="paramname"><em>attrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declarator_syntax.html">DeclaratorSyntax</a> *&#160;</td>
          <td class="paramname"><em>innerDecltor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>direct-declarator</em>.</p>
<pre class="fragment">direct-declarator:
   identifier
   ( declarator )
   direct-declarator [ ... ]
   direct-declarator ( ... )
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.6 </dd></dl>

</div>
</div>
<a id="affe3a21e96d9bd6b4359b17e2a72fedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe3a21e96d9bd6b4359b17e2a72fedb">&#9670;&nbsp;</a></span>parseDoStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseDoStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>iteration-statement</em> of the <code>do</code> <em>statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.5.2 </dd></dl>

</div>
</div>
<a id="a28ae7ee94ec11955694e327f32f3956a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ae7ee94ec11955694e327f32f3956a">&#9670;&nbsp;</a></span>parseEnumerator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseEnumerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>enumerator</em>.</p>
<pre class="fragment">enumerator:
    enumeration-constant
    enumeration-constant = constant-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.2.2 </dd></dl>

</div>
</div>
<a id="a42fa51ec44f6740ef75ba8aa414141c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fa51ec44f6740ef75ba8aa414141c9">&#9670;&nbsp;</a></span>parseExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>expression</em>. <a href="https://docs.google.com/spreadsheets/d/1oGjtFaqLzSoBEp2aGNgHrbEHxSi4Ijv57mXMPymZEcQ/edit?usp=sharing">This table </a> describes the choices taken by the parser as according to the grammar rules.</p>
<pre class="fragment">expression:
    assignment-expression
    expression , assignment-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.17</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The naming convention employed in certain expression-parsing methods, e.g., in <code>Parser::parseExpressionWithPrecedence_CAST</code>, deviates a bit from the usual convention employed in parsing methods. This difference is due to the precedence-oriented way in which the grammar of expressions is defined; had said method been named <code>parseCastExpression</code>, after its rule name <em>cast-expression</em>, one could have expected that its result would always be a <a class="el" href="classpsy_1_1_c_1_1_cast_expression_syntax.html" title="The CastExpressionSyntax class.">CastExpressionSyntax</a> node (a correspondence that holds in general). But this is not true, given that a <em>cast-expression</em> may actually derive an <em>constant</em>, whose node is a <a class="el" href="classpsy_1_1_c_1_1_constant_expression_syntax.html" title="The ConstantExpressionSyntax class.">ConstantExpressionSyntax</a>. </dd></dl>

</div>
</div>
<a id="aa89c6c8ba6411780467a5c02229fd8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89c6c8ba6411780467a5c02229fd8a9">&#9670;&nbsp;</a></span>parseExpressionInitializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionInitializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_initializer_syntax.html">InitializerSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>initializer</em> that is an <em>assignment-expression</em>.</p>
<p>In the adjusted grammar of <a class="el" href="classpsy_1_1_c_1_1_parser.html#ae4712d7d67611f10c720d5b8a548991a">Parser::parseInitializer</a>.</p>
<pre class="fragment">expression-initializer:
    assignment-expression
</pre> 
</div>
</div>
<a id="a29c8ec09ba416869936ecaa1ea73bfaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c8ec09ba416869936ecaa1ea73bfaa">&#9670;&nbsp;</a></span>parseExpressionStatement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>expression-statement</em>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.3 </dd></dl>

</div>
</div>
<a id="a307888d9ef76bbeddf92c65507b43582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307888d9ef76bbeddf92c65507b43582">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceAdditive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceAdditive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>additive-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">additive-expression:
    multiplicative-expression
    additive-expression + multiplicative-expression
    additive-expression - multiplicative-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.6 </dd></dl>

</div>
</div>
<a id="a399b45d275b9101bc55bc23e5824708f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399b45d275b9101bc55bc23e5824708f">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceAssignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>assignment-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">assignment-expression:
    conditional-expression
    unary-expression assignment-operator assignment-expression

assignment-operator: one of
    = *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.16 </dd></dl>

</div>
</div>
<a id="ac40684485112192872a11c8d4a4148bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40684485112192872a11c8d4a4148bf">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceBitwiseAND()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceBitwiseAND </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>AND-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">AND-expression:
    equality-expression
    AND-expression &amp; equality-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.10 </dd></dl>

</div>
</div>
<a id="a0599cabb52e49f01d45fa40cc0f5372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0599cabb52e49f01d45fa40cc0f5372c">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceBitwiseOR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceBitwiseOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>inclusive-OR-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">inclusive-OR-expression:
    exclusive-OR-expression
    inclusive-OR-expression | exclusive-OR-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.12 </dd></dl>

</div>
</div>
<a id="aa139257060635e260f72bea66935d78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa139257060635e260f72bea66935d78e">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceBitwiseXOR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceBitwiseXOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>exclusive-OR-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">exclusive-OR-expression:
    AND-expression
    exclusive-OR-expression ^ AND-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.11 </dd></dl>

</div>
</div>
<a id="a1b4157d96aeb0c54866129a82e7ba8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4157d96aeb0c54866129a82e7ba8c1">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>cast-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">cast-expression:
    unary-expression
    ( type-name ) cast-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.4 </dd></dl>

</div>
</div>
<a id="a298005a4530d0e5436c34392cc9c0e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298005a4530d0e5436c34392cc9c0e9d">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceComma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceComma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse the comman operator, which is a sequence of expressions.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.5.17 </dd>
<dd>
<a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a> </dd></dl>

</div>
</div>
<a id="a072c2948806f4d349afd6ec6be7c9940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072c2948806f4d349afd6ec6be7c9940">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceConditional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>conditional-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">conditional-expression:
    logical-OR-expression
    logical-OR-expression ? expression : conditional-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.15 </dd></dl>

</div>
</div>
<a id="a59e10aeffe0834cf1346492b551faab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e10aeffe0834cf1346492b551faab1">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceEquality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceEquality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>multiplicative-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">equality-expression:
    relational-expression
    equality-expression == relational-expression
    equality-expression != relational-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.9 </dd></dl>

</div>
</div>
<a id="a1269429f313fd3bd940ec5b5977e40e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1269429f313fd3bd940ec5b5977e40e6">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceLogicalAND()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceLogicalAND </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>logical-AND-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">logical-AND-expression:
    inclusive-OR-expression
    logical-AND-expression &amp;&amp; inclusive-OR-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.13 </dd></dl>

</div>
</div>
<a id="a6a8c30961d6899f033a1350b242a51e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8c30961d6899f033a1350b242a51e0">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceLogicalOR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceLogicalOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>logical-OR-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">logical-OR-expression:
    logical-AND-expression
    logical-OR-expression || logical-AND-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.14 </dd></dl>

</div>
</div>
<a id="aa7026710387deb1cbb42df4cf10cbaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7026710387deb1cbb42df4cf10cbaf7">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceMultiplicative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceMultiplicative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>multiplicative-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">multiplicative-expression:
    cast-expression
    multiplicative-expression * cast-expression
    multiplicative-expression / cast-expression
    multiplicative-expression % cast-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.5 </dd></dl>

</div>
</div>
<a id="aacc508cede9cc1d63a0ee0e84ea3c0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc508cede9cc1d63a0ee0e84ea3c0e0">&#9670;&nbsp;</a></span>parseExpressionWithPrecedencePostfix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedencePostfix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>postfix-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">postfix-expression:
    primary-expression
    postfix-expression [ expression ]
    postfix-expression ( argument-expression-list_opt )
    postfix-expression . identifier
    postfix-expression -&gt; identifier
    postfix-expression ++
    postfix-expression --
    ( type-name ) { initializer-list }
    ( type-name) { initializer-list, }

primary-expression:
    identifier
    constant
    string-literal
    ( expression )
    generic-selection
    __builtin_va_arg ( assignment-expression , type-name )
</pre><p>Adjusted grammar:</p>
<pre class="fragment">postfix-expression:
    compound-literal-at-open-paren
    primary-expression postfix-expression-at-follow-of-primary
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.2 </dd></dl>

</div>
</div>
<a id="aef23fa347ab61074c02384d8e6a2e8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef23fa347ab61074c02384d8e6a2e8b4">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceRelational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceRelational </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>relational-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">relational-expression:
    shift-expression
    relational-expression &lt; shift-expression
    relational-expression &gt; shift-expression
    relational-expression &lt;= shift-expression
    relational-expression &gt;= shift-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.8 </dd></dl>

</div>
</div>
<a id="ade33702c958c7b7088cc18dca9860f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade33702c958c7b7088cc18dca9860f06">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceShift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>shift-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">shift-expression:
    additive-expression
    shift-expression &lt;&lt; additive-expression
    shift-expression &gt;&gt; additive-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.7 </dd></dl>

</div>
</div>
<a id="a72841484d25c289e096620b716898425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72841484d25c289e096620b716898425">&#9670;&nbsp;</a></span>parseExpressionWithPrecedenceUnary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExpressionWithPrecedenceUnary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>unary-expression</em>, or any expression that is subsumed by such rule.</p>
<p>See note about naming convention in <a class="el" href="classpsy_1_1_c_1_1_parser.html#a42fa51ec44f6740ef75ba8aa414141c9">Parser::parseExpression</a>.</p>
<pre class="fragment">unary-expression:
    postfix-expression
    ++ unary-expression
    -- unary-expression
    unary-operator cast-expression
    sizeof unary-expression
    sizeof ( type-name )
    _Alignof ( type-name )

unary-operator: &amp; * + - ~ !
</pre><p>Adjusted grammar:</p>
<pre class="fragment">unary-expression:
    postfix-expression
    prefix-unary-expression-at-first unary-expression
    prefix-unary-expression-at-first cast-expression
    type-trait-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.3 </dd></dl>

</div>
</div>
<a id="a9af6f1747c824e8989f37b557f4ac3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af6f1747c824e8989f37b557f4ac3e1">&#9670;&nbsp;</a></span>parseExternalDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExternalDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>external-declaration</em>.</p>
<pre class="fragment">external-declaration:
    function-definition
    declaration
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.9 </dd></dl>

</div>
</div>
<a id="a4b004a81758a91d0eef8408a7597b39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b004a81758a91d0eef8408a7597b39e">&#9670;&nbsp;</a></span>parseExtGNU_AsmStatement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_AsmStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an ASM instruction <em>statement</em>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>J.5.10.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a> </dd></dl>

</div>
</div>
<a id="a2f27ff930220f92c7985f6a5d5c78eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f27ff930220f92c7985f6a5d5c78eee">&#9670;&nbsp;</a></span>parseExtGNU_AsmStatementDeclaration_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_AsmStatementDeclaration_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a GNU extension file-scope assembly <em>statement</em> as a <em>declaration</em>, with LA(1) at FIRST. </p>

</div>
</div>
<a id="aac7739c0ecde34eb30359475391e5097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7739c0ecde34eb30359475391e5097">&#9670;&nbsp;</a></span>parseExtGNU_Attribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_Attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_ext_g_n_u___attribute_syntax.html">ExtGNU_AttributeSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a GNU extension <em>attribute</em>. </p>

</div>
</div>
<a id="a5c0b528dca3199f47521f56a19b70e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0b528dca3199f47521f56a19b70e46">&#9670;&nbsp;</a></span>parseExtGNU_AttributeArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_AttributeArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>exprList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse the arguments of a GNU extension <em>attribute</em>. </p>

</div>
</div>
<a id="a66366cb197d2905a9aa91040cd4faf75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66366cb197d2905a9aa91040cd4faf75">&#9670;&nbsp;</a></span>parseExtGNU_AttributeArgumentsLLVM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_AttributeArgumentsLLVM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExpressionListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>exprList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse the arguments of a GNU extension <em>attribute</em> of LLVM.</p>
<p>The default parsing for the arguments of an <em>attribute</em> is that of an <em>expression-list</em>, but LLVM's <code>availability</code> argument requires "special" handling: the clauses <code>introduced</code>, <code>obsolete</code>, etc. contain <code>version</code> specifier, which may be a tuple of three separated integers (which don't make up for floating point).</p>
<div class="fragment"><div class="line">__attribute__((availability(macosx,introduced=10.12.1))) void f();</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a href="https://clang.llvm.org/docs/AttributeReference.html#availability">https://clang.llvm.org/docs/AttributeReference.html#availability</a> </dd></dl>

</div>
</div>
<a id="accacaa73c9d4941adf371fac27dd6c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accacaa73c9d4941adf371fac27dd6c76">&#9670;&nbsp;</a></span>parseExtGNU_AttributeList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_AttributeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ExtGNU_AttributeListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>attrList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>attribute-list</em> of GNU extension <em>attribute-specifier</em>. </p>

</div>
</div>
<a id="aa14b91b581cf17a7b22926abf0fd8b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14b91b581cf17a7b22926abf0fd8b6f">&#9670;&nbsp;</a></span>parseExtGNU_AttributeSpecifier_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_AttributeSpecifier_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an a GNU extension <em>attribute-specifier</em>. </p>

</div>
</div>
<a id="a2ba42192dd32efea91d59587234bd29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba42192dd32efea91d59587234bd29d">&#9670;&nbsp;</a></span>parseExtGNU_AttributeSpecifierList_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_AttributeSpecifierList_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>specList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a GNU extension <em>attribute-specifier</em> list. </p>

</div>
</div>
<a id="a8b6eafb27cae97bc912b2af102d1fa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6eafb27cae97bc912b2af102d1fa65">&#9670;&nbsp;</a></span>parseExtGNU_ChooseExpression_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_ChooseExpression_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse the GNU built-in function <code>__builtin_choose_expr</code>. </p>

</div>
</div>
<a id="a606d4dd254878aaa45b8b047e722d6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606d4dd254878aaa45b8b047e722d6b6">&#9670;&nbsp;</a></span>parseExtGNU_ComplexValuedExpression_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_ComplexValuedExpression_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>exprK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse the GNU <b>real</b> and <b>imag</b> expressions. </p>

</div>
</div>
<a id="a0df4db8c4d6bec1e0243b33fde6b6d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df4db8c4d6bec1e0243b33fde6b6d0a">&#9670;&nbsp;</a></span>parseExtGNU_StatementExpression_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_StatementExpression_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a GNU extension <em>statements-and-declaration</em> in <em>expression</em>, with LA(1) at FIRST and LA(2) at FOLLOW.</p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs">https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs</a> </p>

</div>
</div>
<a id="a65b1cbb11491962e403152c633f466fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b1cbb11491962e403152c633f466fa">&#9670;&nbsp;</a></span>parseExtGNU_Typeof_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseExtGNU_Typeof_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a GNU extension <code>typeof</code> <em>specifier</em>. </p>

</div>
</div>
<a id="aaabca754b1198b388214ac0d27ca27c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabca754b1198b388214ac0d27ca27c2">&#9670;&nbsp;</a></span>parseForStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseForStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>iteration-statement</em> of the <code>for</code> <em>statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.5.3 </dd></dl>

</div>
</div>
<a id="a36d260579a11e6a8d5e75766aa817a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d260579a11e6a8d5e75766aa817a90">&#9670;&nbsp;</a></span>parseGenericAssociation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseGenericAssociation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_generic_association_syntax.html">GenericAssociationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>assoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">GenericAssociationListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>assocList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>generic-association</em>.</p>
<pre class="fragment">generic-association:
    type-name : assignment-expression
    default: assignment-expression
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.1.1 </dd></dl>

</div>
</div>
<a id="acb688db8fed0523d465fbffb84a0a0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb688db8fed0523d465fbffb84a0a0db">&#9670;&nbsp;</a></span>parseGenericAssociationList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseGenericAssociationList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">GenericAssociationListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>assocList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>generic-assoc-list</em>.</p>
<pre class="fragment">generic-assoc-list:
    generic-association
    generic-assoc-list , generic-association
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.1.1 </dd></dl>

</div>
</div>
<a id="a7b71d18d5770c42c6ee4e47bf06e7ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b71d18d5770c42c6ee4e47bf06e7ff6">&#9670;&nbsp;</a></span>parseGenericSelectionExpression_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseGenericSelectionExpression_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>generic-selection</em>, with LA(1) at FIRST.</p>
<pre class="fragment">generic-selection:
    _Generic ( assignment-expression , generic-assoc-list )
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.1.1 </dd></dl>

</div>
</div>
<a id="aff926c1309ef3671e80efa2335d71381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff926c1309ef3671e80efa2335d71381">&#9670;&nbsp;</a></span>parseGotoStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseGotoStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>jump-statement</em> of the <code>goto</code> <em>statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.6.1 </dd></dl>

</div>
</div>
<a id="a1708b29fc61bbd0cfc008d98e27cf267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1708b29fc61bbd0cfc008d98e27cf267">&#9670;&nbsp;</a></span>parseIdentifierName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseIdentifierName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>identifier</em>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.4.2 and 6.5.1 </dd></dl>

</div>
</div>
<a id="a608ea6025178276dd81cc1d678ad1960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608ea6025178276dd81cc1d678ad1960">&#9670;&nbsp;</a></span>parseIdentifierName_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::parseIdentifierName_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>identifier</em> as an <em>expression</em>, with LA(1) at FIRST.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.4.2 and 6.5.1 </dd></dl>

</div>
</div>
<a id="a986ed810d3f63d77690892816f109efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986ed810d3f63d77690892816f109efc">&#9670;&nbsp;</a></span>parseIfStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseIfStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>selection-statement</em>, of the <code>if</code> <em>statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.4.1 </dd></dl>

</div>
</div>
<a id="ae4712d7d67611f10c720d5b8a548991a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4712d7d67611f10c720d5b8a548991a">&#9670;&nbsp;</a></span>parseInitializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseInitializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_initializer_syntax.html">InitializerSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>initializer</em>.</p>
<pre class="fragment">initializer:
    assignment-expression
    { initializer-list }
    { initializer-list, }
</pre><p>Adjusted grammar:</p>
<pre class="fragment">initializer:
    expression-initializer
    brace-enclosed-initializer
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.9 </dd></dl>

</div>
</div>
<a id="a2daa8904b5786d6d72452e33c631f495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2daa8904b5786d6d72452e33c631f495">&#9670;&nbsp;</a></span>parseLabeledStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseLabeledStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>labeled-statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.1 </dd></dl>

</div>
</div>
<a id="a6ee404b7502eb7a95a754b6eec1c7ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee404b7502eb7a95a754b6eec1c7ca8">&#9670;&nbsp;</a></span>parseOffsetOfDesignator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseOffsetOfDesignator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_designator_syntax.html">DesignatorSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>desig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse Standard's <code>offsetof</code> and GNU's <code>__builtin_offsetof</code> <em>member-designator</em>. </p>

</div>
</div>
<a id="a539dbfa51bbc89613f9bac075e8ab58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539dbfa51bbc89613f9bac075e8ab58d">&#9670;&nbsp;</a></span>parseOffsetOfExpression_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseOffsetOfExpression_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse GNU's <code>__builtin_offsetof</code> and Standard <code>offsetof</code>. </p>

</div>
</div>
<a id="ac379beaf1852b6356da4482869a09b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac379beaf1852b6356da4482869a09b9b">&#9670;&nbsp;</a></span>parseParameterDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseParameterDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_parameter_declaration_syntax.html">ParameterDeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>paramDecl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>parameter-declaration</em>.</p>
<pre class="fragment">parameter-declaration:
    declaration-specifiers declarator
    declaration-specifiers abstract-decltor_opt
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.6 </dd></dl>

</div>
</div>
<a id="a1ff9e41f2093e2373d355f68fab2926a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff9e41f2093e2373d355f68fab2926a">&#9670;&nbsp;</a></span>parseParameterDeclarationList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseParameterDeclarationList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_separated_list.html">ParameterDeclarationListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>paramList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>parameter-list</em>; or, informally, a "parameter-declaration-
  list".</p>
<pre class="fragment">parameter-list:
    parameter-declaration
    parameter-list , parameter-declaration
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.6 </dd></dl>

</div>
</div>
<a id="a20695ee6cc25c03caa3f24951b6a3c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20695ee6cc25c03caa3f24951b6a3c93">&#9670;&nbsp;</a></span>parseParameterDeclarationListAndOrEllipsis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseParameterDeclarationListAndOrEllipsis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_parameter_suffix_syntax.html">ParameterSuffixSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>paramDecltorSfx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>parameter-type-list</em>; or, informally, a "parameter-declaration-
  list-and-or-ellipsis".</p>
<pre class="fragment">parameter-type-list:
    parameter-list
    parameter-list , ...
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.6 </dd></dl>

</div>
</div>
<a id="a5d35e7fd7baddf42e75284a2e4521efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d35e7fd7baddf42e75284a2e4521efe">&#9670;&nbsp;</a></span>parseParenthesizedExpression_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseParenthesizedExpression_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>parenthesized-expression</em>, with LA(1) at FIRST.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.5.1 </dd></dl>

</div>
</div>
<a id="ac0cd1483b6b9d3b7557cb810e4e330f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cd1483b6b9d3b7557cb810e4e330f4">&#9670;&nbsp;</a></span>parsePostfixExpression_AtFollowOfPrimary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parsePostfixExpression_AtFollowOfPrimary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjusted grammar:</p>
<pre class="fragment">postfix-expression-at-follow-of-primary:
    [ expression ] postfix-expression-at-follow-of-primary
    ( argument-expression-list_opt ) postfix-expression-at-follow-of-primary
     . identifier postfix-expression-at-follow-of-primary
    -&gt; identifier postfix-expression-at-follow-of-primary
    ++ postfix-expression-at-follow-of-primary
    -- postfix-expression-at-follow-of-primary
    ε
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.2 </dd></dl>

</div>
</div>
<a id="a4b4f2305ff6283b2501bbafba0bde622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4f2305ff6283b2501bbafba0bde622">&#9670;&nbsp;</a></span>parsePostfixExpression_AtFollowOfPrimary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExprT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parsePostfixExpression_AtFollowOfPrimary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>exprK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(ExprT *&amp;)&gt;&#160;</td>
          <td class="paramname"><em>parsePostfix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>postfix-expression</em>, with LA(1) at the postfix start.</p>
<p>In the adjusted grammar of <a class="el" href="classpsy_1_1_c_1_1_parser.html#aacc508cede9cc1d63a0ee0e84ea3c0e0">Parser::parseExpressionWithPrecedencePostfix</a>.</p>
<pre class="fragment">postfix-expression-at-postfix:
    [ expression ]
    ( argument-expression-list_opt )
    . identifier
    -&gt; identifier
    ++
    --
</pre> 
</div>
</div>
<a id="a121eab4eee45d6879ffaccc51f90d8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121eab4eee45d6879ffaccc51f90d8f9">&#9670;&nbsp;</a></span>parsePredefinedName_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::parsePredefinedName_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>predefined</em> name as an <em>expression</em>, with LA(1) at first. </p>

</div>
</div>
<a id="a546ff2bacd3f620c2ea4397e1ad9286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546ff2bacd3f620c2ea4397e1ad9286a">&#9670;&nbsp;</a></span>parsePrefixUnaryExpression_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parsePrefixUnaryExpression_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>exprK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(Parser::*)(<a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;)&#160;</td>
          <td class="paramname"><em>parseOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>unary-expression</em> that is a <b>prefix</b> <em>unary</em> expression, with LA(1) at the operator.</p>
<p>In the adjusted grammar of <a class="el" href="classpsy_1_1_c_1_1_parser.html#a72841484d25c289e096620b716898425">Parser::parseExpressionWithPrecedenceUnary</a>.</p>
<pre class="fragment">prefix-unary-expression-at-first:
    ++ unary-expression
    -- unary-expression
    unary-operator cast-expression

unary-operator: &amp; * + - ~ !
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.3 </dd></dl>

</div>
</div>
<a id="acfd5a30595011ebd334e17c71063d1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd5a30595011ebd334e17c71063d1f3">&#9670;&nbsp;</a></span>parseReturnStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseReturnStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>jump-statement</em> of the <code>return</code> <em>statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.6.4 </dd></dl>

</div>
</div>
<a id="a856f16692fa6a40954209aadcaf5f2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856f16692fa6a40954209aadcaf5f2ef">&#9670;&nbsp;</a></span>parseSpecifierQualifierList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseSpecifierQualifierList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>specList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>specifier-qualifier-list</em>.</p>
<pre class="fragment">specifier-qualifier-list:
    type-specifier specifier-qualifier-list_opt
    type-qualifier specifier-qualifier-list_opt
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.2.1 </dd></dl>

</div>
</div>
<a id="a1522f05e48327c5cc6e297e0fe7318a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1522f05e48327c5cc6e297e0fe7318a7">&#9670;&nbsp;</a></span>parseStatement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>statement</em>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8 </dd></dl>

</div>
</div>
<a id="a85f82802e6eb142b61961b60faab4efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f82802e6eb142b61961b60faab4efc">&#9670;&nbsp;</a></span>parseStaticAssertDeclaration_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseStaticAssertDeclaration_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>static_assert-declaration</em>, with LA(1) at FIRST.</p>
<pre class="fragment">static_assert-declaration:
    _Static_assert ( constant-expression , string-literal ) ;
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.10 </dd></dl>

</div>
</div>
<a id="a947584f91b96f8b7e8c7d5412b3f03ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947584f91b96f8b7e8c7d5412b3f03ab">&#9670;&nbsp;</a></span>parseStringLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseStringLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>string-literal</em>. </p>

</div>
</div>
<a id="a5fafcb6b7a9448c844ea9903375decf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fafcb6b7a9448c844ea9903375decf1">&#9670;&nbsp;</a></span>parseStringLiteral_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::parseStringLiteral_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>string-literal</em>, with LA(1) at FIRST.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.4.5 and 6.5.1 </dd></dl>

</div>
</div>
<a id="ad842c96a58dff6e9d9a6e4f2101210a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad842c96a58dff6e9d9a6e4f2101210a8">&#9670;&nbsp;</a></span>parseStructDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseStructDeclaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>struct-declaration</em>.</p>
<pre class="fragment">struct-declaration:
    specifier-qualifier-list struct-declarator-list_opt ;
    static_assert-declaration
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.2.1 </dd></dl>

</div>
</div>
<a id="a0069b5e560093b7ac850f75a2ea2ef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0069b5e560093b7ac850f75a2ea2ef2d">&#9670;&nbsp;</a></span>parseSwitchStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseSwitchStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>selection-statement</em> of the <code>witch</code> <em>statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.4.2 </dd></dl>

</div>
</div>
<a id="ab79804621659d99a94b3da3a14580f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79804621659d99a94b3da3a14580f03">&#9670;&nbsp;</a></span>parseTagTypeSpecifier_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TypeDeclT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseTagTypeSpecifier_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>declK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>specK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(Parser::*)(<a class="el" href="classpsy_1_1_c_1_1_declaration_syntax.html">DeclarationSyntax</a> *&amp;)&#160;</td>
          <td class="paramname"><em>parseMember</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>struct-or-union-specifier</em> or a <em>enum-specifier</em>. The parsing of the declaration of the members of either the <code>struct</code> (and <code>union</code>) or the <code>enum</code> is specified through a parameter of function type.</p>
<pre class="fragment">struct-or-union-specifier:
    struct-or-union identifier_opt { struct-declaration-list }
    struct-or-union identifier

struct-declaration-list:
    struct-declaration

 struct-declaration:
    struct-declaration-list struct-declaration

enum-specifier:
    enum identifier_opt { enumerator-list }
    enum identifier_opt { enumerator-list , }
    enum identifier
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.2.1 </dd>
<dd>
6.7.2.3-6, 6.7.2.3-8, and 6.7.2.3-8. </dd></dl>

</div>
</div>
<a id="a99667beb8a441fa17ce48730575f21fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99667beb8a441fa17ce48730575f21fb">&#9670;&nbsp;</a></span>parseTranslationUnit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::parseTranslationUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_translation_unit_syntax.html">TranslationUnitSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>unit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>translation-unit</em>. </p>

</div>
</div>
<a id="a75d0dd72e0e390a9df3b022cdd0b6d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d0dd72e0e390a9df3b022cdd0b6d98">&#9670;&nbsp;</a></span>parseTrivialSpecifier_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpecT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template void Parser::parseTrivialSpecifier_AtFirst&lt; <a class="el" href="classpsy_1_1_c_1_1_ext_g_n_u___asm_qualifier_syntax.html">ExtGNU_AsmQualifierSyntax</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>specK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a "trivial" specifier, which is one of:</p>
<p>a <em>storage-class-specifier</em>, a <em></em>(builtin) type-specifer, a <em>type-qualifier</em>, a <em>function-specifier</em>, or a <em>GNU</em> ext asm-qualifier.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.7.1, 6.7.2, 6.7.3, and 6.7.4 </dd></dl>

</div>
</div>
<a id="ae0cd47a5dd734b69ffcca5dc5942991c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cd47a5dd734b69ffcca5dc5942991c">&#9670;&nbsp;</a></span>parseTypedefName_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::parseTypedefName_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_specifier_syntax.html">SpecifierSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>typedef-name</em> specifier.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.7.8 </dd></dl>

</div>
</div>
<a id="a8177335140e90abb517a0fe696bbaf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8177335140e90abb517a0fe696bbaf1e">&#9670;&nbsp;</a></span>parseTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_type_name_syntax.html">TypeNameSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>type-name</em>.</p>
<pre class="fragment">type-name:
    specifier-qualifier-list abstract-decltor_opt
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.7. </dd></dl>

</div>
</div>
<a id="a98e739f6e335bc4e7c2034ab5918dc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e739f6e335bc4e7c2034ab5918dc62">&#9670;&nbsp;</a></span>parseTypeQualifiersAndAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseTypeQualifiersAndAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_syntax_node_plain_list.html">SpecifierListSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>specList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>pointer</em> <em>declarator</em>.</p>
<pre class="fragment">pointer:
    * type-qualifier-list_opt
    * type_qualifier-list_opt pointer
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.7.6.1. </dd></dl>

</div>
</div>
<a id="a500984502247fb47f00d410b506bbe92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500984502247fb47f00d410b506bbe92">&#9670;&nbsp;</a></span>parseTypeTraitExpression_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseTypeTraitExpression_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>exprK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a <em>unary-expression</em> that is type-trait <em>unary</em> expression, with LA(1) at FIRST.</p>
<p>In the adjusted grammar of <a class="el" href="classpsy_1_1_c_1_1_parser.html#a72841484d25c289e096620b716898425">Parser::parseExpressionWithPrecedenceUnary</a>.</p>
<pre class="fragment">type-trait-expression:
    sizeof unary-expression
    sizeof ( type-name )
    _Alignof ( type-name )
</pre><dl class="section remark"><dt>Remarks</dt><dd>6.5.3 </dd></dl>

</div>
</div>
<a id="ac6bb496d301922ab2ad3a0b283e3ba24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bb496d301922ab2ad3a0b283e3ba24">&#9670;&nbsp;</a></span>parseVAArgumentExpression_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseVAArgumentExpression_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_expression_syntax.html">ExpressionSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classpsy_1_1_c_1_1_parser.html" title="The C Parser class.">Parser</a> the variable argument "macro" <code>va_arg</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>7.16.1.1 </dd></dl>

</div>
</div>
<a id="a15bb57dcb339b6a72d4d456666f77b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bb57dcb339b6a72d4d456666f77b71">&#9670;&nbsp;</a></span>parseWhileStatement_AtFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::parseWhileStatement_AtFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpsy_1_1_c_1_1_statement_syntax.html">StatementSyntax</a> *&amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StatementContext&#160;</td>
          <td class="paramname"><em>stmtCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse an <em>iteration-statement</em> of the <code>while</code> <em>statement</em>, with LA(1) at <code>FIRST</code>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>6.8.5.1 </dd></dl>

</div>
</div>
<a id="a31b9e29d4bf8a03a73c87238fe1df74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b9e29d4bf8a03a73c87238fe1df74a">&#9670;&nbsp;</a></span>skipTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::skipTo </td>
          <td>(</td>
          <td class="paramtype">SyntaxKind&#160;</td>
          <td class="paramname"><em>tkK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Skip until a token of the given kind is found. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C/parser/<a class="el" href="_parser_8h_source.html">Parser.h</a></li>
<li>C/parser/Parser.cpp</li>
<li>C/parser/Parser_Common.cpp</li>
<li>C/parser/Parser_Declarations.cpp</li>
<li>C/parser/Parser_Expressions.cpp</li>
<li>C/parser/Parser_Statements.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
